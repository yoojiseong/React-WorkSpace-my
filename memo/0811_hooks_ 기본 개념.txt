함수형 컴포넌트에서,  hooks , 개념 및 기본기.
- hook : 고리, 특정 시점에서 끼어 들어서 동작을 수행함.
일반적인 실행 흐름 : a -> b-> c -> d -> e
Hook 사용시 : a -> b -> hook 실행 -> c -> d -> e
=====================================================================
1
useState
: React의 함수형 컴포넌트에서 상태(state)를 관리하기 위해 사용하는 Hook
상태 ?
컴포넌트의 데이터로, 값이 변경되면 화면(UI)을 자동으로 다시 렌더링합니다.
주요 특징
상태 값 저장: 컴포넌트 내에서 값을 유지
값 변경 시 자동 렌더링: UI가 상태 변화에 맞게 자동 업데이트
함수형 컴포넌트 전용: 클래스형 컴포넌트의 this.state와 같은 역할
기본 문법
const [state, setState] = useState(initialValue);

state: 현재 상태 값
setState: 상태를 변경하는 함수
initialValue: 상태의 초기값
=====================================================================
2
useEffect
: 사이드 이펙트(Side Effect) 처리하기 위한 hook
사이드 이펙트(Side Effect) ?
컴포넌트의 렌더링 과정 외부에서 발생하는 작업
1) API 호출 ,
2) DOM 직접 조작, (포커서, 스크롤, 등)
3) 타이머 설정 / 해제
4) 이벤트 리스너 등록 / 해제
5) 콘솔 로그, 로컬 스토리지에 저장.

기본 문법
useEffect(콜백함수, [의존성배열]);
useEffect(() => {
  // 실행할 코드
  return () => {
    // 정리(clean-up) 코드 (선택)
  };
}, [의존성배열]);

첫 번째 인자: 실행할 함수
두 번째 인자([]): 의존성 배열 (언제 실행할지 결정)

[] 빈 배열 → 최초 1회 실행 (마운트 시)

[값] 특정 값 변경 시 실행

없으면 → 렌더링마다 실행
=====================================================================
3
useReducer
:  상태 관리 로직이 복잡할 때 사용하는 Hook
다양한 상태 변경 패턴을 한 곳에서 관리할 수 있도록 도와줌.
왜 사용하나요?
1)
상태 변경 로직이 if/else나 setState 중첩으로 복잡해질 때
2)
여러 개의 상태 값이 서로 연관되어 변경될 때
3) 상태 관리 라이브러리 사용할 때,
Redux와 유사한 방식으로 액션 기반 상태 관리를 하고 싶을 때

기본 문법
const [state, dispatch] = useReducer(reducer, initialState);

state: 현재 상태 값
dispatch: 상태 변경 요청 함수
reducer: (state, action) => newState 형태의 함수
initialState: 초기 상태 값
=====================================================================
4
useMemo
메모이제이션(Memoization)된 값을 반환하는 Hook
메모이제이션(Memoization) ?
이미 계산한 값을 기억해두었다가,
동일한 계산을 반복해야 할 때
다시 계산하는 대신 기억해 둔 값을 바로 반환하여
성능을 최적화하는 기술입니다.
useMemo는 복잡한 연산의 결과값을 기억합니다.

사용처
1
성능 최적화: 렌더링마다 반복되는 복잡한 연산이나
계산 비용이 큰 함수의 실행을 방지하여 성능 저하를 막습니다.
2
불필요한 계산 방지: 의존성 배열의 값이 변경될 때만
콜백 함수를 다시 실행하여 값을 계산합니다.

기본문법
예시
useMemo(콜백함수, [의존성 배열])
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
:
useMemo가 반환하는 메모이제이션된 값.
의존성([a,b])이 바뀌지 않으면
이전 렌더링에서 계산된 값을 그대로 사용합니다.
=====================================================================
5
useCallback
: 메모이제이션(Memoization)된 함수를 반환하는 Hook

useMemo가 값(value)을 기억하는 반면,
useCallback은 함수(function) 자체를 기억합니다.
렌더링이 발생해도 의존성 배열의 값이 변경되지 않으면
이전에 생성된 함수를 그대로 재사용합니다.

사용처
1
자식 컴포넌트의 불필요한 리렌더링 방지:
함수형 컴포넌트는 렌더링될 때마다 내부에 선언된 함수도 새로 생성됩니다.
이 새로운 함수를 자식 컴포넌트에 props로 전달하면,
자식 컴포넌트는 부모로부터 받은 props가 변경되었다고 인식하여
불필요하게 리렌더링될 수 있습니다.
useCallback은 함수를 재사용하게 하여 이를 방지합니다.
(React.memo와 함께 사용할 때 효과가 극대화됩니다.)
2
의존성 관리:
useEffect와 같은 다른 Hook의 의존성 배열에 함수를 포함해야 할 때,
렌더링마다 함수가 재생성되어
useEffect가 불필요하게 계속 실행되는 것을 막을 수 있습니다.

기본문법
useCallback(콜백 함수, [의존성 배열])
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
=====================================================================
6
useRef
: 렌더링에 영향을 주지 않는, 변경 가능한(mutable) 데이터를 저장하거나
DOM 요소에 직접 접근할 때 사용하는 Hook
주의, 값을 변경해도 컴포넌트가 리렌더링되지 않습니다.

사용처,
1
DOM 요소 직접 접근: 특정 DOM 요소에 포커스를 맞추거나,
스크롤 위치를 조작하거나,
비디오/오디오를 재생하는 등 DOM을 직접 제어해야 할 때 사용합니다.

2
리렌더링 없는 값 저장: 렌더링 사이클 전체에 걸쳐 유지되어야 하지만,
그 값의 변경이 화면 업데이트를 유발해서는
안 되는 값을 저장할 때 유용합니다.
(예: 타이머의 ID, 이전 상태 값, 변경은 되어야 하지만 화면에는 보이지 않는 값 등)

기본 문법
const refContainer = useRef(initialValue);
예시)
const inputEl = useRef(null);

// 값에 접근하거나 변경할 때
refContainer.current = 'some value';
console.log(refContainer.current);
예시)
 const onInsert = (e) => { ...생략
 inputEl.current.focus();
 }

// JSX에서 DOM 요소에 연결할 때
<input ref={refContainer} />
예시)
<input ...생략 ref={inputEl} />

=====================================================================
7
커스텀 훅스
:재사용 가능한 상태 관련 로직을 컴포넌트로부터 추출하기 위한 JavaScript 함수

React에 내장된 특정 기능이 아니라,
여러 컴포넌트에서 반복되는 로직(예: 데이터 가져오기, 폼 상태 관리 등)을
묶어 자신만의 훅으로 만드는 디자인 패턴입니다.

사용처
1
로직의 재사용성: 여러 컴포넌트에서
동일한 로직(예: useState와 useEffect를 함께 사용하는 패턴)을
반복해서 작성할 필요가 없어집니다.
2
관심사의 분리: 컴포넌트는 UI를 렌더링하는 역할에 집중하고,
복잡한 상태 관리 로직은 커스텀 훅으로 분리하여
코드를 더 깔끔하고 이해하기 쉽게 만듭니다.
3
독립적인 상태: 커스텀 훅을 사용하는
각 컴포넌트는 서로 영향을 주지 않는 독립적인 상태를 가집니다.









